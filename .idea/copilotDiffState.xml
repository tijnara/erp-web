<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/vos-erp/src/app/api/auth/login-rfid/route.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/vos-erp/src/app/api/auth/login-rfid/route.ts" />
              <option name="originalContent" value="// src/app/api/auth/login-rfid/route.ts&#10;export const runtime = 'nodejs';&#10;&#10;import { NextResponse } from 'next/server';&#10;import { z } from 'zod';&#10;import { SignJWT } from 'jose';&#10;&#10;const DIRECTUS = (process.env.NEXT_PUBLIC_DIRECTUS_URL ?? '').replace(/\/+$/,'');&#10;const M_EMAIL = process.env.DIRECTUS_MACHINE_EMAIL;&#10;const M_PASS  = process.env.DIRECTUS_MACHINE_PASSWORD;&#10;&#10;const APP_ACCESS  = process.env.APP_ACCESS_COOKIE  ?? 'vos_app_access';&#10;const APP_REFRESH = process.env.APP_REFRESH_COOKIE ?? 'vos_app_refresh';&#10;const secret = new TextEncoder().encode(process.env.AUTH_JWT_SECRET ?? 'dev-secret-change-me');&#10;&#10;const Body = z.object({ rf: z.string().min(1) });&#10;&#10;function bitAsBool(v: any): boolean {&#10;    if (v === 1 || v === true) return true;&#10;    if (v === 0 || v === false || v == null) return false;&#10;    if (typeof v === 'object' &amp;&amp; Array.isArray(v.data)) return v.data[0] === 1;&#10;    return false;&#10;}&#10;&#10;async function sign(payload: any, seconds: number) {&#10;    return await new SignJWT(payload)&#10;        .setProtectedHeader({ alg: 'HS256' })&#10;        .setIssuedAt()&#10;        .setExpirationTime(`${seconds}s`)&#10;        .sign(secret);&#10;}&#10;&#10;export async function POST(req: Request) {&#10;    try {&#10;        if (!DIRECTUS) {&#10;            return NextResponse.json({ error: 'Missing NEXT_PUBLIC_DIRECTUS_URL' }, { status: 500 });&#10;        }&#10;&#10;        const body = await req.json().catch(() =&gt; ({}));&#10;        const p = Body.safeParse(body);&#10;        if (!p.success) return NextResponse.json({ error: 'Invalid input' }, { status: 400 });&#10;&#10;        // 1) optional: login as machine user for a scoped token&#10;        let token: string | undefined;&#10;        if (M_EMAIL &amp;&amp; M_PASS) {&#10;            const authRes = await fetch(`${DIRECTUS}/auth/login`, {&#10;                method: 'POST',&#10;                headers: { 'Content-Type': 'application/json' },&#10;                body: JSON.stringify({ email: M_EMAIL, password: M_PASS }),&#10;            });&#10;            const auth = await authRes.json().catch(() =&gt; ({}));&#10;            if (authRes.ok) {&#10;                token = auth?.data?.access_token;&#10;            } else {&#10;                console.warn('RFID machine login failed:', authRes.status, auth?.errors?.[0]?.message);&#10;                token = undefined; // proceed without token; permissions may allow public lookup&#10;            }&#10;        }&#10;&#10;        // 2) lookup by rf_id (DO NOT request user_password)&#10;        const url =&#10;            `${DIRECTUS}/items/user` +&#10;            `?limit=1` +&#10;            `&amp;fields=user_id,user_email,user_fname,user_lname,role_id,isAdmin,rf_id,is_deleted,isDeleted` +&#10;            `&amp;filter[rf_id][_eq]=${encodeURIComponent(p.data.rf)}`;&#10;&#10;        const ures = await fetch(url, {&#10;            headers: token ? { Authorization: `Bearer ${token}` } : undefined,&#10;            cache: 'no-store',&#10;        });&#10;&#10;        const json = await ures.json().catch(() =&gt; ({}));&#10;&#10;        if (!ures.ok) {&#10;            const msg = json?.errors?.[0]?.message || 'RFID lookup failed (permissions /items/user)';&#10;            return NextResponse.json({ error: msg }, { status: ures.status || 401 });&#10;        }&#10;&#10;        const u = json?.data?.[0];&#10;        if (!u) return NextResponse.json({ error: 'RFID not found' }, { status: 404 });&#10;&#10;        const deleted  = bitAsBool(u.is_deleted) || bitAsBool(u.isDeleted);&#10;        const inactive = (u.status ?? 'active') === 'inactive';&#10;        if (deleted || inactive) {&#10;            return NextResponse.json({ error: 'Account disabled' }, { status: 403 });&#10;        }&#10;&#10;        // 3) mint app-session cookies (JWT)&#10;        const name = [u.user_fname, u.user_lname].filter(Boolean).join(' ') || u.user_email || u.rf_id || '';&#10;        const payload = {&#10;            sub: String(u.user_id),&#10;            email: u.user_email ?? '',&#10;            name,&#10;            isAdmin: !!u.isAdmin,&#10;            role_id: u.role_id ?? null,&#10;            auth_kind: 'rfid' as const,&#10;        };&#10;&#10;        const access  = await sign(payload, 60 * 15);       // 15m&#10;        const refresh = await sign(payload, 60 * 60 * 24);  // 1d&#10;&#10;        const isProd = process.env.NODE_ENV === 'production';&#10;        const res = NextResponse.json({ ok: true, user: payload });&#10;        res.cookies.set(APP_ACCESS,  access,  { httpOnly: true, sameSite: 'lax', secure: isProd, path: '/', maxAge: 60 * 15 });&#10;        res.cookies.set(APP_REFRESH, refresh, { httpOnly: true, sameSite: 'lax', secure: isProd, path: '/', maxAge: 60 * 60 * 24 });&#10;        return res;&#10;    } catch (e: any) {&#10;        console.error('RFID_LOGIN_ERROR:', e);&#10;        return NextResponse.json({ error: e?.message || 'Internal error' }, { status: 500 });&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="// src/app/api/auth/login-rfid/route.ts&#10;export const runtime = 'nodejs';&#10;&#10;import { NextResponse } from 'next/server';&#10;import { z } from 'zod';&#10;import { SignJWT } from 'jose';&#10;import { supabase } from '@/lib/supabase';&#10;&#10;const APP_ACCESS  = process.env.APP_ACCESS_COOKIE  ?? 'vos_app_access';&#10;const APP_REFRESH = process.env.APP_REFRESH_COOKIE ?? 'vos_app_refresh';&#10;const secret = new TextEncoder().encode(process.env.AUTH_JWT_SECRET ?? 'dev-secret-change-me');&#10;&#10;const Body = z.object({ rf: z.string().min(1) });&#10;&#10;async function sign(payload: any, seconds: number) {&#10;    return await new SignJWT(payload)&#10;        .setProtectedHeader({ alg: 'HS256' })&#10;        .setIssuedAt()&#10;        .setExpirationTime(`${seconds}s`)&#10;        .sign(secret);&#10;}&#10;&#10;export async function POST(req: Request) {&#10;    try {&#10;        const body = await req.json().catch(() =&gt; ({}));&#10;        const p = Body.safeParse(body);&#10;        if (!p.success) return NextResponse.json({ error: 'Invalid input' }, { status: 400 });&#10;&#10;        // Query user by RFID from Supabase&#10;        const { data: user, error } = await supabase&#10;            .from('users')&#10;            .select('user_id, user_email, user_fname, user_lname, role_id, is_admin, rf_id, is_deleted, status')&#10;            .eq('rf_id', p.data.rf)&#10;            .single();&#10;&#10;        if (error || !user) {&#10;            return NextResponse.json({ error: 'RFID not found' }, { status: 404 });&#10;        }&#10;&#10;        // Check if account is deleted or inactive&#10;        if (user.is_deleted || user.status === 'inactive') {&#10;            return NextResponse.json({ error: 'Account disabled' }, { status: 403 });&#10;        }&#10;&#10;        // Create session token&#10;        const sessionId = crypto.randomUUID();&#10;&#10;        // Update user's session token in database&#10;        await supabase&#10;            .from('users')&#10;            .update({ session_token: sessionId })&#10;            .eq('user_id', user.user_id);&#10;&#10;        // Mint app-session cookies (JWT)&#10;        const name = [user.user_fname, user.user_lname].filter(Boolean).join(' ') || user.user_email || user.rf_id || '';&#10;        const payload = {&#10;            sub: String(user.user_id),&#10;            email: user.user_email ?? '',&#10;            name,&#10;            isAdmin: !!user.is_admin,&#10;            role_id: user.role_id ?? null,&#10;            auth_kind: 'rfid' as const,&#10;            jti: sessionId,&#10;        };&#10;&#10;        const access  = await sign(payload, 60 * 15);       // 15m&#10;        const refresh = await sign(payload, 60 * 60 * 24);  // 1d&#10;&#10;        const isProd = process.env.NODE_ENV === 'production';&#10;        const res = NextResponse.json({ ok: true, user: payload });&#10;        res.cookies.set(APP_ACCESS,  access,  { httpOnly: true, sameSite: 'lax', secure: isProd, path: '/', maxAge: 60 * 15 });&#10;        res.cookies.set(APP_REFRESH, refresh, { httpOnly: true, sameSite: 'lax', secure: isProd, path: '/', maxAge: 60 * 60 * 24 });&#10;        return res;&#10;    } catch (e: any) {&#10;        console.error('RFID_LOGIN_ERROR:', e);&#10;        return NextResponse.json({ error: e?.message || 'Internal error' }, { status: 500 });&#10;    }&#10;}&#13;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/vos-erp/src/app/api/price-types/route.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/vos-erp/src/app/api/price-types/route.ts" />
              <option name="originalContent" value="import { NextResponse } from &quot;next/server&quot;;&#10;&#10;export async function GET() {&#10;    try {&#10;        // Directus removed: return mock data or fetch from alternative source&#10;        const priceTypes = [&#10;            { id: 1, name: &quot;Retail&quot; },&#10;            { id: 2, name: &quot;Wholesale&quot; }&#10;        ];&#10;        return NextResponse.json(priceTypes);&#10;    } catch (error) {&#10;        console.error(&quot;Error fetching price types:&quot;, error);&#10;        return NextResponse.json({ error: &quot;Failed to fetch price types&quot; }, { status: 500 });&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="import { NextResponse } from &quot;next/server&quot;;&#10;import { supabase } from &quot;@/lib/supabase&quot;;&#10;&#10;export async function GET() {&#10;    try {&#10;        const { data, error } = await supabase&#10;            .from(&quot;price_types&quot;)&#10;            .select(&quot;price_type_id, price_type_name&quot;)&#10;            .order(&quot;sort&quot;, { ascending: true });&#10;&#10;        if (error) {&#10;            console.error(&quot;Error fetching price types:&quot;, error);&#10;            return NextResponse.json({ error: &quot;Failed to fetch price types&quot; }, { status: 500 });&#10;        }&#10;&#10;        // Map to expected format&#10;        const priceTypes = (data || []).map(item =&gt; ({&#10;            id: item.price_type_id,&#10;            name: item.price_type_name,&#10;        }));&#10;&#10;        return NextResponse.json(priceTypes);&#10;    } catch (error) {&#10;        console.error(&quot;Error fetching price types:&quot;, error);&#10;        return NextResponse.json({ error: &quot;Failed to fetch price types&quot; }, { status: 500 });&#10;    }&#10;}&#13;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/vos-erp/src/config/api.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/vos-erp/src/config/api.ts" />
              <option name="originalContent" value="// src/config/api.ts&#10;// Centralized API base URL and helpers for vos-erp&#10;&#10;export type ApiConfig = {&#10;  baseUrl: string;&#10;};&#10;&#10;// UPDATE: Use localhost for development, or an Environment Variable&#10;const DEFAULT_BASE_URL = process.env.NEXT_PUBLIC_API_URL || &quot;http://localhost:8090&quot;;&#10;&#10;// Resolve base URL with a runtime override if provided via window.__VOS_API_BASE__&#10;function resolveBaseUrl(): string {&#10;  const w: any = typeof window !== &quot;undefined&quot; ? (window as any) : undefined;&#10;  const fromWindow = w?.__VOS_API_BASE__;&#10;  if (typeof fromWindow === &quot;string&quot; &amp;&amp; fromWindow.trim().length &gt; 0) {&#10;    // Ensure no trailing slash&#10;    return fromWindow.replace(/\/+$/, &quot;&quot;);&#10;  }&#10;  return DEFAULT_BASE_URL;&#10;}&#10;&#10;export const API_BASE_URL: string = resolveBaseUrl();&#10;&#10;export function apiUrl(path: string): string {&#10;  const base = API_BASE_URL.replace(/\/+$/, &quot;&quot;);&#10;  const cleanPath = path.replace(/^\/+/, &quot;&quot;);&#10;  return `${base}/${cleanPath}`;&#10;}&#10;&#10;&#10;export const ITEMS_BASE = apiUrl(&quot;items&quot;);&#10;&#10;export function itemsUrl(path: string = &quot;&quot;): string {&#10;  const clean = path.replace(/^\/+/, &quot;&quot;);&#10;  return clean ? `${ITEMS_BASE}/${clean}` : ITEMS_BASE;&#10;}&#10;" />
              <option name="updatedContent" value="// src/config/api.ts&#10;// API configuration for vos-erp&#10;// Note: This file is kept for legacy compatibility but most API calls now use Supabase directly&#10;&#10;export type ApiConfig = {&#10;  baseUrl: string;&#10;};&#10;&#10;// Legacy support - no longer used with Supabase&#10;const DEFAULT_BASE_URL = process.env.NEXT_PUBLIC_API_URL || &quot;http://localhost:8090&quot;;&#10;&#10;function resolveBaseUrl(): string {&#10;  const w: any = typeof window !== &quot;undefined&quot; ? (window as any) : undefined;&#10;  const fromWindow = w?.__VOS_API_BASE__;&#10;  if (typeof fromWindow === &quot;string&quot; &amp;&amp; fromWindow.trim().length &gt; 0) {&#10;    return fromWindow.replace(/\/+$/, &quot;&quot;);&#10;  }&#10;  return DEFAULT_BASE_URL;&#10;}&#10;&#10;export const API_BASE_URL: string = resolveBaseUrl();&#10;&#10;export function apiUrl(path: string): string {&#10;  const base = API_BASE_URL.replace(/\/+$/, &quot;&quot;);&#10;  const cleanPath = path.replace(/^\/+/, &quot;&quot;);&#10;  return `${base}/${cleanPath}`;&#10;}&#10;&#10;export const ITEMS_BASE = apiUrl(&quot;items&quot;);&#10;&#10;export function itemsUrl(path: string = &quot;&quot;): string {&#10;  const clean = path.replace(/^\/+/, &quot;&quot;);&#10;  return clean ? `${ITEMS_BASE}/${clean}` : ITEMS_BASE;&#10;}&#13;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/vos-erp/src/constants.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/vos-erp/src/constants.ts" />
              <option name="originalContent" value="export const API_BASE = &quot;http://100.119.3.44:8090/items&quot;;&#10;export const INVENTORY_STATUS: { [key: number]: string } = { 0: &quot;Pending&quot;, 1: &quot;Partial&quot;, 2: &quot;Received&quot; };&#10;export const INVENTORY_STATUS_COLOR: { [key: number]: string } = { 0: &quot;status-pending&quot;, 1: &quot;status-partial&quot;, 2: &quot;status-received&quot; };&#10;export const PAYMENT_STATUS: { [key: number]: string } = { 1: &quot;Unpaid&quot;, 2: &quot;Paid&quot; };&#10;export const PAYMENT_STATUS_COLOR: { [key: number]: string } = { 1: &quot;status-unpaid&quot;, 2: &quot;status-paid&quot; };&#10;&#10;" />
              <option name="updatedContent" value="export const INVENTORY_STATUS: { [key: number]: string } = { 0: &quot;Pending&quot;, 1: &quot;Partial&quot;, 2: &quot;Received&quot; };&#10;export const INVENTORY_STATUS_COLOR: { [key: number]: string } = { 0: &quot;status-pending&quot;, 1: &quot;status-partial&quot;, 2: &quot;status-received&quot; };&#10;export const PAYMENT_STATUS: { [key: number]: string } = { 1: &quot;Unpaid&quot;, 2: &quot;Paid&quot; };&#10;export const PAYMENT_STATUS_COLOR: { [key: number]: string } = { 1: &quot;status-unpaid&quot;, 2: &quot;status-paid&quot; };&#13;&#10;&#13;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/vos-erp/src/hooks/useFetchInitialData.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/vos-erp/src/hooks/useFetchInitialData.ts" />
              <option name="originalContent" value="import { usePurchaseOrderStore } from &quot;@/store/usePurchaseOrderStore&quot;;&#10;import { API_BASE } from &quot;@/constants&quot;;&#10;&#10;export const useFetchInitialData = () =&gt; {&#10;  const {&#10;    setPurchaseOrders,&#10;    setProducts,&#10;    setReceiving,&#10;    setSuppliers,&#10;    setBranches,&#10;    setLineDiscounts,&#10;    setTaxRates,&#10;  } = usePurchaseOrderStore();&#10;&#10;  const fetchInitialData = async () =&gt; {&#10;    try {&#10;      const [poData, productData, receivingData, suppliersData, branchesData, lineDiscountsData, taxRatesData] = await Promise.all([&#10;        fetch(`${API_BASE}/purchase_order`).then(res =&gt; res.json()),&#10;        fetch(`${API_BASE}/purchase_order_products`).then(res =&gt; res.json()),&#10;        fetch(`${API_BASE}/purchase_order_receiving`).then(res =&gt; res.json()),&#10;        fetch(`${API_BASE}/suppliers`).then(res =&gt; res.json()),&#10;        fetch(`${API_BASE}/branches`).then(res =&gt; res.json()),&#10;        fetch(`${API_BASE}/line_discount?limit=-1`).then(res =&gt; res.json()),&#10;        fetch(`${API_BASE}/tax_rates`).then(res =&gt; res.json()),&#10;      ]);&#10;      setPurchaseOrders(poData.data || []);&#10;      setProducts(productData.data || []);&#10;      setReceiving(receivingData.data || []);&#10;      setSuppliers(suppliersData.data || []);&#10;      setBranches(branchesData.data || []);&#10;      setLineDiscounts(lineDiscountsData.data || []);&#10;      if (taxRatesData.data &amp;&amp; taxRatesData.data.length &gt; 0) {&#10;        setTaxRates({&#10;          VATRate: parseFloat(taxRatesData.data[0].VATRate) || 0,&#10;          WithholdingRate: parseFloat(taxRatesData.data[0].WithholdingRate) || 0,&#10;        });&#10;      }&#10;    } catch (error) {&#10;      // You can add error handling here&#10;      console.error(&quot;Error fetching initial data:&quot;, error);&#10;    }&#10;  };&#10;&#10;  return { fetchInitialData };&#10;};&#10;" />
              <option name="updatedContent" value="import { usePurchaseOrderStore } from &quot;@/store/usePurchaseOrderStore&quot;;&#10;import { supabase } from &quot;@/lib/supabase&quot;;&#10;&#10;export const useFetchInitialData = () =&gt; {&#10;  const {&#10;    setPurchaseOrders,&#10;    setProducts,&#10;    setReceiving,&#10;    setSuppliers,&#10;    setBranches,&#10;    setLineDiscounts,&#10;    setTaxRates,&#10;  } = usePurchaseOrderStore();&#10;&#10;  const fetchInitialData = async () =&gt; {&#10;    try {&#10;      // Fetch all data from Supabase&#10;      const [&#10;        { data: poData },&#10;        { data: productData },&#10;        { data: receivingData },&#10;        { data: suppliersData },&#10;        { data: branchesData },&#10;        { data: lineDiscountsData },&#10;        { data: taxRatesData },&#10;      ] = await Promise.all([&#10;        supabase.from(&quot;purchase_order&quot;).select(&quot;*&quot;),&#10;        supabase.from(&quot;purchase_order_products&quot;).select(&quot;*&quot;),&#10;        supabase.from(&quot;purchase_order_receiving&quot;).select(&quot;*&quot;),&#10;        supabase.from(&quot;suppliers&quot;).select(&quot;*&quot;),&#10;        supabase.from(&quot;branches&quot;).select(&quot;*&quot;),&#10;        supabase.from(&quot;line_discount&quot;).select(&quot;*&quot;),&#10;        supabase.from(&quot;tax_rates&quot;).select(&quot;*&quot;),&#10;      ]);&#10;&#10;      setPurchaseOrders(poData || []);&#10;      setProducts(productData || []);&#10;      setReceiving(receivingData || []);&#10;      setSuppliers(suppliersData || []);&#10;      setBranches(branchesData || []);&#10;      setLineDiscounts(lineDiscountsData || []);&#10;      &#10;      if (taxRatesData &amp;&amp; taxRatesData.length &gt; 0) {&#10;        setTaxRates({&#10;          VATRate: parseFloat(taxRatesData[0].VATRate) || 0,&#10;          WithholdingRate: parseFloat(taxRatesData[0].WithholdingRate) || 0,&#10;        });&#10;      }&#10;    } catch (error) {&#10;      console.error(&quot;Error fetching initial data:&quot;, error);&#10;    }&#10;  };&#10;&#10;  return { fetchInitialData };&#10;};&#13;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/vos-erp/src/lib/asset-url.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/vos-erp/src/lib/asset-url.ts" />
              <option name="originalContent" value="/**&#10; * Standardizes asset URLs.&#10; * If the URL is already a full http link (from Supabase), return it.&#10; * If it's a legacy Directus ID (UUID), construct the Directus URL (optional fallback).&#10; * If it's a local path, ensure it starts with /.&#10; */&#10;export function assetUrl(fileIdOrUrl?: string | null, params?: Record&lt;string, string&gt;) {&#10;    if (!fileIdOrUrl) return '';&#10;&#10;    // 1. If it's already a full URL (e.g. from Supabase Storage), return it directly&#10;    if (fileIdOrUrl.startsWith('http') || fileIdOrUrl.startsWith('/uploads/')) {&#10;        return fileIdOrUrl;&#10;    }&#10;&#10;    // 2. Legacy Directus Support: If it looks like a UUID, assume it's an old Directus ID&#10;    // (Matches standard UUID format: 8-4-4-4-12 hex digits)&#10;    if (fileIdOrUrl.match(/^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$/)) {&#10;        const base = `${process.env.NEXT_PUBLIC_DIRECTUS_URL}/assets/${fileIdOrUrl}`;&#10;        if (!params) return base;&#10;        const q = new URLSearchParams(params);&#10;        return `${base}?${q.toString()}`;&#10;    }&#10;&#10;    // 3. Fallback&#10;    return fileIdOrUrl;&#10;}&#10;" />
              <option name="updatedContent" value="/**&#10; * Standardizes asset URLs.&#10; * If the URL is already a full http link (from Supabase), return it.&#10; * If it's a local path, return it as-is.&#10; */&#10;export function assetUrl(fileIdOrUrl?: string | null, params?: Record&lt;string, string&gt;) {&#10;    if (!fileIdOrUrl) return '';&#10;&#10;    // If it's already a full URL (e.g. from Supabase Storage), return it directly&#10;    if (fileIdOrUrl.startsWith('http') || fileIdOrUrl.startsWith('/uploads/') || fileIdOrUrl.startsWith('/')) {&#10;        return fileIdOrUrl;&#10;    }&#10;&#10;    // Fallback: return as-is&#10;    return fileIdOrUrl;&#10;}&#13;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/vos-erp/src/modules/replicated-module/providers/fetchProvider.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/vos-erp/src/modules/replicated-module/providers/fetchProvider.ts" />
              <option name="originalContent" value="import { apiUrl } from &quot;@/config/api&quot;;&#10;&#10;export function fetchProvider() {&#10;    const apiUrlBase = apiUrl(&quot;replicated&quot;);&#10;&#10;    async function fetchReplicated(page: number) {&#10;        const response = await fetch(`${apiUrlBase}?page=${page}&amp;limit=20`);&#10;        if (!response.ok) {&#10;            throw new Error(&quot;Failed to fetch replicated data&quot;);&#10;        }&#10;        return response.json();&#10;    }&#10;&#10;    async function registerReplicated(data: any) {&#10;        const response = await fetch(apiUrlBase, {&#10;            method: &quot;POST&quot;,&#10;            headers: {&#10;                &quot;Content-Type&quot;: &quot;application/json&quot;,&#10;            },&#10;            body: JSON.stringify(data),&#10;        });&#10;        if (!response.ok) {&#10;            throw new Error(&quot;Failed to register replicated data&quot;);&#10;        }&#10;    }&#10;&#10;    return { fetchReplicated, registerReplicated };&#10;}&#10;" />
              <option name="updatedContent" value="import { supabase } from &quot;@/lib/supabase&quot;;&#10;&#10;export function fetchProvider() {&#10;    async function fetchReplicated(page: number) {&#10;        const limit = 20;&#10;        const offset = (page - 1) * limit;&#10;&#10;        const { data, error, count } = await supabase&#10;            .from(&quot;replicated&quot;)&#10;            .select(&quot;*&quot;, { count: &quot;exact&quot; })&#10;            .range(offset, offset + limit - 1);&#10;&#10;        if (error) {&#10;            throw new Error(&quot;Failed to fetch replicated data: &quot; + error.message);&#10;        }&#10;&#10;        return {&#10;            data: data || [],&#10;            total: count || 0,&#10;        };&#10;    }&#10;&#10;    async function registerReplicated(data: any) {&#10;        const { error } = await supabase&#10;            .from(&quot;replicated&quot;)&#10;            .insert(data);&#10;&#10;        if (error) {&#10;            throw new Error(&quot;Failed to register replicated data: &quot; + error.message);&#10;        }&#10;    }&#10;&#10;    return { fetchReplicated, registerReplicated };&#10;}&#13;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>